{"ast":null,"code":"import _asyncToGenerator from \"/Users/sujee/Desktop/feelDiary/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport getBlobDuration from 'get-blob-duration';\nimport { alreadyRecordingError, couldNotQueryPermissionStatusError, deviceCannotVoiceRecordError, failedToFetchRecordingError, failedToRecordError, failureResponse, missingPermissionError, recordingHasNotStartedError, successResponse } from './predefined-web-responses'; // these mime types will be checked one by one in order until one of them is found to be supported by the current browser\n\nconst possibleMimeTypes = ['audio/aac', 'audio/webm;codecs=opus', 'audio/mp4', 'audio/webm', 'audio/ogg;codecs=opus'];\n\nconst neverResolvingPromise = () => new Promise(() => undefined);\n\nexport class VoiceRecorderImpl {\n  constructor() {\n    this.mediaRecorder = null;\n    this.chunks = [];\n    this.pendingResult = neverResolvingPromise();\n  }\n\n  static canDeviceVoiceRecord() {\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      if (((_a = navigator === null || navigator === void 0 ? void 0 : navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.getUserMedia) == null || VoiceRecorderImpl.getSupportedMimeType() == null) {\n        return failureResponse();\n      } else {\n        return successResponse();\n      }\n    })();\n  }\n\n  startRecording() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this.mediaRecorder != null) {\n        throw alreadyRecordingError();\n      }\n\n      const deviceCanRecord = yield VoiceRecorderImpl.canDeviceVoiceRecord();\n\n      if (!deviceCanRecord.value) {\n        throw deviceCannotVoiceRecordError();\n      }\n\n      const havingPermission = yield VoiceRecorderImpl.hasAudioRecordingPermission().catch(() => successResponse());\n\n      if (!havingPermission.value) {\n        throw missingPermissionError();\n      }\n\n      navigator.mediaDevices.getUserMedia({\n        audio: true\n      }).then(_this.onSuccessfullyStartedRecording.bind(_this)).catch(_this.onFailedToStartRecording.bind(_this));\n      return successResponse();\n    })();\n  }\n\n  stopRecording() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this2.mediaRecorder == null) {\n        throw recordingHasNotStartedError();\n      }\n\n      try {\n        _this2.mediaRecorder.stop();\n\n        _this2.mediaRecorder.stream.getTracks().forEach(track => track.stop());\n\n        return _this2.pendingResult;\n      } catch (ignore) {\n        throw failedToFetchRecordingError();\n      } finally {\n        _this2.prepareInstanceForNextOperation();\n      }\n    })();\n  }\n\n  static hasAudioRecordingPermission() {\n    return _asyncToGenerator(function* () {\n      return navigator.permissions.query({\n        name: 'microphone'\n      }).then(result => ({\n        value: result.state === 'granted'\n      })).catch(() => {\n        throw couldNotQueryPermissionStatusError();\n      });\n    })();\n  }\n\n  static requestAudioRecordingPermission() {\n    return _asyncToGenerator(function* () {\n      const havingPermission = yield VoiceRecorderImpl.hasAudioRecordingPermission().catch(() => failureResponse());\n\n      if (havingPermission.value) {\n        return successResponse();\n      }\n\n      return navigator.mediaDevices.getUserMedia({\n        audio: true\n      }).then(() => successResponse()).catch(() => failureResponse());\n    })();\n  }\n\n  pauseRecording() {\n    if (this.mediaRecorder == null) {\n      throw recordingHasNotStartedError();\n    } else if (this.mediaRecorder.state === 'recording') {\n      this.mediaRecorder.pause();\n      return Promise.resolve(successResponse());\n    } else {\n      return Promise.resolve(failureResponse());\n    }\n  }\n\n  resumeRecording() {\n    if (this.mediaRecorder == null) {\n      throw recordingHasNotStartedError();\n    } else if (this.mediaRecorder.state === 'paused') {\n      this.mediaRecorder.resume();\n      return Promise.resolve(successResponse());\n    } else {\n      return Promise.resolve(failureResponse());\n    }\n  }\n\n  getCurrentStatus() {\n    if (this.mediaRecorder == null) {\n      return Promise.resolve({\n        status: 'NONE'\n      });\n    } else if (this.mediaRecorder.state === 'recording') {\n      return Promise.resolve({\n        status: 'RECORDING'\n      });\n    } else if (this.mediaRecorder.state === 'paused') {\n      return Promise.resolve({\n        status: 'PAUSED'\n      });\n    } else {\n      return Promise.resolve({\n        status: 'NONE'\n      });\n    }\n  }\n\n  static getSupportedMimeType() {\n    if ((MediaRecorder === null || MediaRecorder === void 0 ? void 0 : MediaRecorder.isTypeSupported) == null) return null;\n    const foundSupportedType = possibleMimeTypes.find(type => MediaRecorder.isTypeSupported(type));\n    return foundSupportedType !== null && foundSupportedType !== void 0 ? foundSupportedType : null;\n  }\n\n  onSuccessfullyStartedRecording(stream) {\n    var _this3 = this;\n\n    this.pendingResult = new Promise((resolve, reject) => {\n      this.mediaRecorder = new MediaRecorder(stream);\n\n      this.mediaRecorder.onerror = () => {\n        reject(failedToRecordError());\n        this.prepareInstanceForNextOperation();\n      };\n\n      this.mediaRecorder.onstop = /*#__PURE__*/_asyncToGenerator(function* () {\n        const mimeType = VoiceRecorderImpl.getSupportedMimeType();\n\n        if (mimeType == null) {\n          reject(failedToFetchRecordingError());\n        } else {\n          const blobVoiceRecording = new Blob(_this3.chunks, {\n            'type': mimeType\n          });\n          const recordDataBase64 = yield VoiceRecorderImpl.blobToBase64(blobVoiceRecording);\n          const recordingDuration = yield getBlobDuration(blobVoiceRecording);\n\n          _this3.prepareInstanceForNextOperation();\n\n          resolve({\n            value: {\n              recordDataBase64,\n              mimeType,\n              msDuration: recordingDuration * 1000\n            }\n          });\n        }\n      });\n\n      this.mediaRecorder.ondataavailable = event => this.chunks.push(event.data);\n\n      this.mediaRecorder.start();\n    });\n  }\n\n  onFailedToStartRecording() {\n    this.prepareInstanceForNextOperation();\n    throw failedToRecordError();\n  }\n\n  static blobToBase64(blob) {\n    return new Promise(resolve => {\n      const reader = new FileReader();\n\n      reader.onloadend = () => {\n        const recordingResult = String(reader.result);\n        const splitResult = recordingResult.split('base64,');\n        const toResolve = splitResult.length > 1 ? splitResult[1] : recordingResult;\n        resolve(toResolve.trim());\n      };\n\n      reader.readAsDataURL(blob);\n    });\n  }\n\n  prepareInstanceForNextOperation() {\n    if (this.mediaRecorder != null && this.mediaRecorder.state === 'recording') {\n      try {\n        this.mediaRecorder.stop();\n      } catch (ignore) {}\n    }\n\n    this.pendingResult = neverResolvingPromise();\n    this.mediaRecorder = null;\n    this.chunks = [];\n  }\n\n} //# sourceMappingURL=VoiceRecorderImpl.js.map","map":null,"metadata":{},"sourceType":"module"}